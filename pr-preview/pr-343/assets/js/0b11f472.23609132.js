"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([["23934"],{600609:function(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var r=t(544136),i=t(785893),o=t(250065);let s={},a="Token based security",c={},l=[{value:"How it works",id:"how-it-works",level:2},{value:"Enable or disable token security for an alias",id:"enable-or-disable-token-security-for-an-alias",level:2},{value:"Configuring THEOplayer to pass the necessary headers",id:"configuring-theoplayer-to-pass-the-necessary-headers",level:2},{value:"1. Create a network interceptor",id:"1-create-a-network-interceptor",level:3},{value:"2. Set the request interceptor",id:"2-set-the-request-interceptor",level:3},{value:"Limitations on iOS devices",id:"limitations-on-ios-devices",level:3}];function d(e){let n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"token-based-security",children:"Token based security"})}),"\n",(0,i.jsx)(n.p,{children:"THEOlive offers the option to enable JWT token security on channel alias level. This can be interesting if you only want valid users to access your stream."}),"\n",(0,i.jsx)(n.p,{children:"In this document, we will"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"explain how it works"}),"\n",(0,i.jsx)(n.li,{children:"how to enable/disable it via the console and API"}),"\n",(0,i.jsx)(n.li,{children:"how to configure your THEOplayer to pass the mandatory headers"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,i.jsxs)(n.p,{children:["When enabling token security on a channel alias, we expect you to share the shared (private) key in case of HS256/HS512 or the public key in case of RS256/RS512 encryption. This will be used on CDN level to determine if a request (with a Bearer token passed in the ",(0,i.jsx)(n.code,{children:"Authorization"})," header) is valid or not. It's up to you to configure this header correctly through our ",(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/theoplayer",children:"npm player"}),". Later in this document we will explain how."]}),"\n",(0,i.jsx)(n.p,{children:"In the bearer token that gets sent to us, we expect the following properties to be available:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"exp"}),": date in epoch format until which the JWT token is valid"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"nbf"}),': optional date in epoch format. Stands for "not before" and acts as a "start date" of the JWT to be valid.']}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"When not passing a bearer token for a secured channel, the request will be rejected."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"token based security",src:t(26259).Z+"",width:"720",height:"306"})}),"\n",(0,i.jsx)(n.h2,{id:"enable-or-disable-token-security-for-an-alias",children:"Enable or disable token security for an alias"}),"\n",(0,i.jsxs)(n.p,{children:["Please refer to the ",(0,i.jsx)(n.a,{href:"/theolive/api/channels/enable-token-security-for-alias",children:"Enable token security for alias"})," and ",(0,i.jsx)(n.a,{href:"/theolive/api/channels/disable-token-security-for-alias",children:"Disable token security for alias"})," API endpoints to manage the token security settings for an alias."]}),"\n",(0,i.jsxs)(n.p,{children:["When enabling for the first time, you have to pass the ",(0,i.jsx)(n.code,{children:"key"})," property in the body. If you disable token security later on, and make it active again, you can omit this property if it should stay the same."]}),"\n",(0,i.jsxs)(n.p,{children:["If you're using the ",(0,i.jsx)(n.a,{href:"https://console.theo.live",children:"THEOlive management console"}),", you can navigate to the player details page and select the alias you want to enable/disable token security for. When enabling, please pass the correct shared or public key to use. ",(0,i.jsx)(n.strong,{children:"Don't forget to confirm your changes by hitting the save button!"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Managing token security in the console",src:t(885667).Z+"",width:"1323",height:"770"})}),"\n",(0,i.jsx)(n.h2,{id:"configuring-theoplayer-to-pass-the-necessary-headers",children:"Configuring THEOplayer to pass the necessary headers"}),"\n",(0,i.jsx)(n.h3,{id:"1-create-a-network-interceptor",children:"1. Create a network interceptor"}),"\n",(0,i.jsxs)(n.p,{children:["First thing to do is to create a header provider function. In this function you add the ",(0,i.jsx)(n.code,{children:"Authorization"})," header which contains a bearer token generated by you. This token should at least contain a ",(0,i.jsx)(n.code,{children:"exp"})," property, and an optional ",(0,i.jsx)(n.code,{children:"nbf"})," property. You can add as many other properties to it as you want, but OptiView live doesn't do anything with them."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",metastring:"Creating header provider",children:"const interceptor = (request) => {\n  const headers = {\n    ...request.headers,\n    Authorization: 'Bearer <token-generated-by-you>',\n  };\n  request.redirect({\n    headers,\n  });\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-set-the-request-interceptor",children:"2. Set the request interceptor"}),"\n",(0,i.jsx)(n.p,{children:"The above defined interceptors can be added to the player as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"player.network.addRequestInterceptor(interceptor);\n"})}),"\n",(0,i.jsx)(n.p,{children:"The player will now include the header in every request that gets made to the CDN to grab content."}),"\n",(0,i.jsx)(n.p,{children:"Similarly, interceptors can be removed, as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"player.network.removeRequestInterceptor(interceptor);\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"An unauthorized error will occur if no token or an invalid token is passed, preventing users from being able to watch the stream."})}),"\n",(0,i.jsx)(n.h3,{id:"limitations-on-ios-devices",children:"Limitations on iOS devices"}),"\n",(0,i.jsx)(n.p,{children:"Apple devices running an iOS version lower than 17.1 do not support MSE, therefore there are limitations with what is possible when playing a THEOlive stream. One such limitation is that the above network interceptor approach does not work on those devices. Instead, a service worker needs to be registered to support playback of JWT enabled streams."}),"\n",(0,i.jsxs)(n.p,{children:["The service worker needs to intercept the ",(0,i.jsx)(n.code,{children:"fetch"})," requests originating from the app, compute a JWT and attach it as a ",(0,i.jsx)(n.code,{children:"Authorization"})," header to the request and dispatch it. As mentioned above, the only key in the JWT that we need is the ",(0,i.jsx)(n.code,{children:"exp"}),", all others are optional and will be ignored by the backend."]}),"\n",(0,i.jsx)(n.p,{children:"A code snippet for the service worker code is shared below."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",metastring:"Service Worker for iOS Safari",children:"// If you are using a symmetric key, then this is the same key as configured in your console.\nconst YOUR_JWT_SIGNING_KEY = 'YOUR-SIGNING-KEY-GOES-HERE';\n\n// Service worker events\nself.addEventListener('install', () => {\n  console.log('Service worker installed!');\n  self.skipWaiting();\n});\n\n// Activation event\nself.addEventListener('activate', (event) => {\n  console.log('Service Worker activated');\n  // Claim clients so the service worker is in effect immediately\n  event.waitUntil(self.clients.claim());\n});\n// Service worker events end\n\n// Utility functions to create JWT\nconst base64UrlEncode = (str) => {\n  return btoa(str).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n};\n\nconst utf8ToUint8Array = (str) => {\n  return new TextEncoder().encode(str);\n};\n\nconst sign = async (payload, secret) => {\n  const header = { alg: 'HS256', typ: 'JWT' };\n\n  const encodedHeader = base64UrlEncode(JSON.stringify(header));\n  const encodedPayload = base64UrlEncode(JSON.stringify(payload));\n\n  const data = `${encodedHeader}.${encodedPayload}`;\n  const secretBytes = utf8ToUint8Array(secret);\n\n  const key = await crypto.subtle.importKey('raw', secretBytes, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n\n  const signature = await crypto.subtle.sign({ name: 'HMAC' }, key, utf8ToUint8Array(data));\n\n  const signatureBytes = new Uint8Array(signature);\n  let signatureStr = '';\n  for (let i = 0; i < signatureBytes.length; i++) {\n    signatureStr += String.fromCharCode(signatureBytes[i]);\n  }\n\n  return `${data}.${base64UrlEncode(signatureStr)}`;\n};\n\n// Intercept the fetch event and add in your JWT\nself.addEventListener('fetch', (event) => {\n  event.respondWith(\n    (async function () {\n      try {\n        const url = new URL(event.request.url);\n        // Only intercept requests made by the player and not other requests\n        if (url.origin.endsWith('theo.live')) {\n          const jwt = await sign(\n            {\n              exp: Math.floor(Date.now() / 1000) + 300, // 5 minutes\n            },\n            YOUR_JWT_SIGNING_KEY\n          );\n\n          // Clone the request and add the JWT header\n          const modifiedRequest = new Request(event.request, {\n            headers: {\n              ...Object.fromEntries(event.request.headers.entries()),\n              Authorization: `Bearer ${jwt}`,\n            },\n          });\n\n          return fetch(modifiedRequest);\n        }\n\n        // For other requests, just pass through\n        return fetch(event.request);\n      } catch (error) {\n        console.error('Error in fetch handler:', error);\n        return new Response('Service Worker Error', { status: 500 });\n      }\n    })()\n  );\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:"And then, to register this service worker in to your code, you can attach it this way."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",metastring:"add service worker",children:"const registerServiceWorker = () => {\n  if ('serviceWorker' in navigator) {\n    // Replace with your own path to the service worker location.\n    navigator.serviceWorker\n      .register('./path/to/your/service-worker.js')\n      .then((reg) => {\n        if (reg.active) console.log('Service worker registered!');\n      })\n      .catch((err) => {\n        console.error('Could not register service worker!', err);\n      });\n  } else {\n    console.error('Service worker not supported!');\n  }\n};\n// Initialise the service worker some time early in the processs.\nif (!(window.MediaSource || window.WebKitMediaSource || window.ManagedMediaSource)) {\n  registerServiceWorker();\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["If you are using a bundler such as vite or rollup etc, you will need to ensure that your service worker also gets copied to our output directory and is ",(0,i.jsx)(n.code,{children:"registered"})," from the correct path."]})})]})}function h(e={}){let{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},885667:function(e,n,t){t.d(n,{Z:()=>r});let r=t.p+"assets/images/51376b6-token-d85cdc1dbfb111642fa9b7f764b921e6.png"},26259:function(e,n,t){t.d(n,{Z:()=>r});let r=t.p+"assets/images/dcdfc37-token_security-198f04847aec73ad4f237ac1e8c7c650.png"},250065:function(e,n,t){t.d(n,{Z:()=>a,a:()=>s});var r=t(667294);let i={},o=r.createContext(i);function s(e){let n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:n},e.children)}},544136:function(e){e.exports=JSON.parse('{"id":"platform/Security/token-based-security","title":"Token based security","description":"THEOlive offers the option to enable JWT token security on channel alias level. This can be interesting if you only want valid users to access your stream.","source":"@site/theolive/platform/Security/token-based-security.mdx","sourceDirName":"platform/Security","slug":"/platform/Security/token-based-security","permalink":"/documentation/pr-preview/pr-343/theolive/platform/Security/token-based-security","draft":false,"unlisted":false,"editUrl":"https://github.com/THEOplayer/documentation/blob/-/theolive/platform/Security/token-based-security.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"theolive","previous":{"title":"Geo-blocking","permalink":"/documentation/pr-preview/pr-343/theolive/platform/Security/geo-blocking"},"next":{"title":"Playback","permalink":"/documentation/pr-preview/pr-343/theolive/playback"}}')}}]);